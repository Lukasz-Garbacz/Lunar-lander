import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.net.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import static javax.swing.JOptionPane.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

/**lunarlander is the main class of the project, it handles all logic
 * except for spaceship movement. Keeps track of time to update spaceship's
 * position, reads game parameters from server file, then local file
 * if server is not available, then generates terrain if server/local file
 * doesn't specify terrain position. Draws UI, terrain and spaceship model,
 * keeps track of all game parameters not directly tied to the spaceship;
 * level number, terrain points, highscores, lives remaining. Reads inputs
 * from user and handles all inputs than aren't arrows, pauses the game by setting
 * time passing = 0 when p is pressed, goes to next level or refreshes level when
 * n is pressed and conditions are met (spaceship has landed or crashed). Initializes
 * spaceship object when redrawing, reads game parameters from file every time n is pressed
 * and n conditions are met.
 *
 * Overall parameters loaded from file (in this order, separated with commas):
 *<ul>
 *<li> maximum lives player has
 *<li> starting X position of the spaceship (0 is left edge)
 *<li> starting Y position of the spaceship (0 is top edge)
 *<li> gravity strength, standard value = 3
 *<li> acceleration rate of the spaceship, standard value = 30;
 *<li> speed with which the spaceship rotates, standard value = 1
 *<li> maximum horizontal speed for successful landing, standard value = 20
 *<li> maximum vertical speed for successful landing, standard value = 20
 *<li> amount of starting fuel the spaceship has, standard value = 500
 *<li> rate at which spaceship's engine consumes fuel, standard value = 15
 *<li> maximum rotation for successful landing, standard value = 0.1
 *<li> R part of RGB color which applies to the platform, standard value = 0
 *<li> G part of RGB color which applies to the platform, standard value = 255
 *<li> B part of RGB color which applies to the platform, standard value = 0
 *<li> R part of RGB color which applies all terrain lines except for the platform, standard value = 255
 *<li> G part of RGB color which applies all terrain lines except for the platform, standard value = 255
 *<li> B part of RGB color which applies all terrain lines except for the platform, standard value = 255
 *<li> int to determine if terrain should be autogenerated, equals 1 if yes, any other value if not
 *<li> number of points for which their heights will be generated, if autogenerated is not 1 it's a placeholder
 *<li> number of points from which the platform is made, if autogenerated is not 1 it's a placeholder
 *<li> slope angle, determines how high the height difference range is autogenerated points, if autogenerated is not 1 it's a placeholder
 *<li> terrain info, 2 dimensional ArrayList holding each level info in one separate array
 *</ul>
 * <p>
 *For terrain info each point's height should be separated with a comma, and an additional semicolon should be added at the end of each line
 *(as it marks the end of current level and beginning of a next one)
 *
 *All drawing happens in the main, in a called draw() which is called in an infinite loop, displaying one frame each time.
 *All drawing parameters are dependent on current window size, so rescaling the window will dynamically rescale terrain
 * and spaceship hitbox; UI doesn't rescale, most of it is tied to the top left corner of the screen, highscores to the top right corner.
 *
 * UI consists of current fuel, score, vertical and horizontal spaceship speed, level counter, lives remaining and 5 top highscores.
 * Highscores are read from the end of the info file, section begins and end with '|'.
 *
 * All terrain lines have thickness of 3 pixels, spaceship's hitbox is a circle of adjustable size which may graphically differ from
 * spaceship's model (as it has different shape and doesn't resize).
 *
 * @author ≈Åukasz Garbacz
 */
public class lunarlander extends PApplet {

    float gravity;
    float accelerationRate;
    float rotationRate;
    float landingXSpeed;
    float landingYSpeed;
    float maxRotation;
    float slopeAngle;
    float fuel;
    float fuelLossRate;
    int numberOfTerrainPoints;
    int platformSize;
    PVector startingPosition = new PVector(50,50);
    int platformColor;
    int lineColor;
    int maxLives;

    int lives = -1;
    String playerName = "";
    boolean serverOnline = true;
    ArrayList<String> highscores = new ArrayList();
    ArrayList<ArrayList<Float>> terrainPoints = new ArrayList();
    int autoGenTerrain;
    int level = 0;
    float currentWidth = 1640;
    float currentHeight = 910;
    boolean reset = true;
    boolean pause = false;
    boolean pauseEnded = false;
    int score = 0;
    String serverInfo = "";
    Spaceship spaceship;

    /** setup is a build in processing function which gets called once per level to determine level parameters
     * and create spaceship object, which gets reset every level.
     * First time it's called it shows a popup to the user to get his username for highscores table.
     * All parameters are loaded by getServerInfo() function.
     * @see #getServerInfo()
     *
     */
    public void setup() {
        if(playerName.length() == 0) {
            playerName = showInputDialog("Please enter username");
        }

        getServerInfo();
        surface.setResizable(true);
        surface.setTitle("LunarLander");
        surface.hideCursor();
        if(autoGenTerrain == 1 || level >= terrainPoints.size()) {
            generateTerrain();
        }
        else {
            numberOfTerrainPoints = terrainPoints.get(level).size();
        }
        spaceship = new Spaceship(startingPosition, gravity, accelerationRate, rotationRate, landingXSpeed, landingYSpeed, fuel, fuelLossRate, maxRotation); // starting spaceship position
    }

    float lastFrameTime = 0;
    float currentFrameTime = 0;
    float timer = 0;

    /**draw is a main drawing function, being called in an infinite loop if looping is set to true
     * (we set it to false to implement pause)
     * @see #keyPressed()
     * It checks if spaceship has landed or crashed and updates parameters (removing lives if crashed,
     * reseting level to 0 if palyer has run out of lives, updates score if player has landed) and
     * resets the board drawing new level.
     * It also keeps track of time elapsed from the last frame to the current one and updates spaceship
     * position accordingly (to avoid speed depending on frame rate (Fallout 76)).
     * @see #updateHighscores()
     * @see #setup();
     * @see #drawTerrain();
     * @see #drawUI();
     *
     */
    public void draw() {
        //print(landingXSpeed + " " + landingYSpeed + " " + maxRotation + "\n");
        //print(spaceship.velocity.x + " " + spaceship.velocity.y + " " + spaceship.rotationValue + "\n");
        spaceship.currentSize = min(spaceship.defaultSize * (height/currentHeight), spaceship.defaultSize * (width/currentWidth));

        //update content after landing or crash
        if((keysPressed.contains(78) || keysPressed.contains(110) ) && !reset && (spaceship.state == State.LANDED || spaceship.state == State.DESTROYED)) {
            reset = true;
            if(spaceship.state == State.LANDED) {
                level++;
                score += spaceship.fuel * 0.2f;
                updateHighscores();
            }
            else {
                if(lives > 1) {
                    lives--;
                }
                else{
                    level = 0;
                    score = 0;
                    terrainPoints.clear();
                    lives = maxLives;
                }
            }
            setup();
        }

        currentFrameTime = millis();
        timer = currentFrameTime - lastFrameTime;
        lastFrameTime = currentFrameTime;
        //update
        if(pauseEnded){
            timer = 0;
            pauseEnded = false;
        }
        spaceship.update(timer);
        //draw
        drawTerrain();
        drawUI();
        spaceship.draw();
    }

    Set<Integer> keysPressed = new HashSet<Integer>();

    /**simple function collecting keys pressed by the user if they are
     * implemented in the program and storing them in a HashSet container.
     * Also implements pause functionality when p is pressed, stopping
     * the calling of draw() and displaying red "PAUSE" letters in the middle
     * of the board.
     * @see #draw()
     * resuming it when p pressed again.
     *
     *
     */
    public void keyPressed() {
        //may have to change later
        if (key == CODED) {
            keysPressed.add(keyCode);
        }
        //n or N
        else if ((key == 78 || key == 110)) {
            keysPressed.add(keyCode);
        }
        //p or P
        else if ((key == 80 || key == 112)) {
            keysPressed.add(keyCode);
            if(pause){
                loop();
                pause = false;
                pauseEnded = true;
            }
            else {
                noLoop();
                pause = true;
                noStroke();
                fill(255,0,0);
                textSize(70);
                text("PAUSE", width/2-140, height/2);
            }
        }
    }

    /**Simple function removing keys pressed by the user from
     * HashSet container, if they are implemented in the project
     */
    public void keyReleased() {
        //may have to change later
        if (key == CODED) {
            keysPressed.remove(keyCode);
        }
        // n or N
        else if ((key == 78 || key == 110)) {
            keysPressed.remove(keyCode);
        }
        //p or P
        else if ((key == 80 || key == 112)) {
            keysPressed.remove(keyCode);
        }
    }

    /**Function responsible for drawing all terrain lines
     * from given points (stored in global terrainPoints container).
     * background is always black, lines are 3 pixels thick,
     * point coordinates are calculated by separate function
     * @see #calculatePoint(int)  takes point index
     */
    public void drawTerrain() {
        background(0,0,0);
        //draw terrain lines
        noFill();
        strokeWeight(3);
        stroke(lineColor);
        beginShape();

        for(int i=0; i<terrainPoints.get(level).size(); i++) {
            if(i < (terrainPoints.get(level).size() - 1)){

                //color platform green
                if(calculatePoint(i + 1).y == calculatePoint(i).y) {
                    stroke(platformColor);
                }
                //make other lines white
                else{
                    stroke(lineColor);
                }
                line(calculatePoint(i).x, calculatePoint(i).y, calculatePoint(i + 1).x, calculatePoint(i + 1).y);
            }
        }
        stroke(lineColor);
        endShape(LINES);
    }

    /**
     *Function calculates x and y coordinates of given point
     * distance between points on x axis is dependent on window width and
     * number of points so that the all fit on the screen and are equally
     * spread. value on Y axis depends on windows height and point height
     * parameter read from terrainPoints arraylist.
     *
     * @param iter index of point to calculate in terrainPoints container
     * @return PVector with x and y coordinates of calculated point
     */
    public PVector calculatePoint(int iter) {
        float xStep = (float)width / (terrainPoints.get(level).size() - 1);
        float x = iter * xStep;
        float y = height - (terrainPoints.get(level).get(iter) * ((float)height/currentHeight));
        return new PVector(x, y);
    }

    /**Auto generate terrain points height value using a noise function
     * denormalized (mapped) to fit screen from the bottom to 80% of its height
     * (constraint necessary to keep enough space for the spaceship to move).
     * If on some rare occasions generated value is below the bottom edge of
     * the screen it's set to 0, which creates a possibility of having more
     * than 1 platform. Platform position is random, platform size determined.
     */
    public void generateTerrain () {
        terrainPoints.add(new ArrayList<Float>());
        int platform = ThreadLocalRandom.current().nextInt(0, numberOfTerrainPoints - platformSize + 1);
        float noiseMult = ThreadLocalRandom.current().nextFloat() * 2;
        terrainPoints.get(level).clear();
        for (int i=0; i<numberOfTerrainPoints; i++) {
            terrainPoints.get(level).add(map(noise(i*slopeAngle*noiseMult*(1 + 0.2f*level)), 0, 1, -0.1f*height, height*0.8f));

            if(terrainPoints.get(level).get(i) < 0) {
                terrainPoints.get(level).add(map(noise(i*slopeAngle*(1 + 0.2f*level)), 0, 1, 0, height*0.8f));
            }
            if(i > platform && i <= (platform + platformSize)) {
                terrainPoints.get(level).set(i, terrainPoints.get(level).get(platform));
            }
        }
    }

    /**Draws white UI near to left and right corner on the window,
     * with constant size (can possibly overlap). UI consist of
     * (from top left):
     * <ul>
     * <li> fuel counter
     * <li> score counter
     * <li> fuel bar (2 white rectangles, 1 filled 1 not)
     * <li> horizontal speed counter
     * <li> vertical speed counter
     * <li> level counter
     * <li> lives counter and box display
     * <li> list of 5 highest scores
     * </ul>
     */
    public void drawUI() {
        //fuel text + bar
        noFill();
        stroke(255,255,255);
        rect(170,10,200,60);
        fill(255,255,255);
        noStroke();
        rect(170,10,spaceship.fuel/fuel*200, 60);
        fill(255,255,255);
        textSize(25);
        text("Fuel: " + PApplet.parseInt(spaceship.fuel), 10 ,35);

        //score
        noStroke();
        fill(255,255,255);
        textSize(25);
        text("Score: " + score, 10 ,70);

        //current spaceship parameters
        text("Horizontal speed: " + -PApplet.parseInt(spaceship.velocity.y), 380 ,35);
        text("Vertical speed: " + PApplet.parseInt(spaceship.velocity.x), 380 ,70);
        text("Level: " + (level+1), 680 ,35);

        //lives
        textSize(25);
        text("Lives: ", 680 ,70);
        for(int i=0; i<3; i++) {
            noFill();
            stroke(255,255,255);
            rect(760+(i*40),46,25,25);
            if(lives > i) {
                fill(255,255,255);
                noStroke();
                rect(760+(i*40),46,25,25);
            }
        }

        textSize(15);
        for(int i=1; i<10; i+=2) {
            text(highscores.get(i-1), width - 130 ,10+10*i);
            text(highscores.get(i), width - 80 ,10+10*i);
        }
    }

    /**Function to establish connection to server
     * set on localhost on port 8080. Server always
     * responds with game data file no matter the request
     * so we just set up a stream and read all server info
     * into 2 strings. one containing all game parameters,
     *  other one containing highscores. Text block that
     *  begins with '/' is ignored. then we parse the
     *  strings with separate functions
     * @see #parseServerInfo()
     * @see #parseHighscoreInfo(String) string with highscores to parse
     *
     * If server is down or we get any other exception while trying to
     * read information from it we load data all the same but from
     * a local file in data directory
     */
    public void getServerInfo() {

        //establish server connection and read info
        try {
            URL u = new URL("http://localhost:8080");
            URLConnection uc = u.openConnection(  );
            InputStream raw = uc.getInputStream(  );
            InputStream buffer = new BufferedInputStream(raw);

            Reader r = new InputStreamReader(buffer);
            int c = r.read();
            while (c != -1 && PApplet.parseChar(c) != 47) {
                serverInfo += PApplet.parseChar(c);
                c = r.read();
            }
            String highscoreInfo = "";
            while (c != -1) {
                c = r.read();
                highscoreInfo += PApplet.parseChar(c);
            }
            highscoreInfo = highscoreInfo.substring(highscoreInfo.indexOf('|')+1);
            parseHighscoreInfo(highscoreInfo);
            parseServerInfo();
        }
        catch(Exception e) {
            System.out.print("Error getting server info: " + e);
            serverOnline = false;
        }

        //if server down read local file
        if(!serverOnline) {
            try{
                String[] lines = loadStrings("LLinfo.txt");
                for (int i = 0 ; i < lines.length; i++) {
                    serverInfo += lines[i];
                }
                String highscoreInfo = serverInfo.substring(serverInfo.indexOf('|')+1);
                serverInfo = serverInfo.substring(0, serverInfo.indexOf('/'));

                parseHighscoreInfo(highscoreInfo);
                parseServerInfo();
            }
            catch(Exception e){
                System.out.print("Error reading local file info: " + e);
            }
        }
    }

    /**prasing function separating info from given string
     * into a highscores array, in format score,playerName,
     * score,playerName, etc. only runs once to avoid
     * overriding highscores set during current session.
     *
     * @param input input string from getServerInfo()
     * @see #getServerInfo()
     */
    public void parseHighscoreInfo (String input) {
        if(highscores.size() != 0) {
            return;
        }
        for(int i=0; i<10; i++){
            input = input.replace("\n", "").replace("\r", "");
            int index = input.indexOf(',');
            String result = input.substring(0,index);
            input = input.substring(index+1);
            highscores.add(result);
        }
    } /**
     * Parses server info read by getServerInfo
     * @see #getServerInfo
     * Overall parameters loaded from string (in this order):
            *<ul>
            *<li> maximum lives player has
            *<li> starting X position of the spaceship (0 is left edge)
            *<li> starting Y position of the spaceship (0 is top edge)
            *<li> gravity strength, standard value = 3
            *<li> acceleration rate of the spaceship, standard value = 30;
            *<li> speed with which the spaceship rotates, standard value = 1
            *<li> maximum horizontal speed for successful landing, standard value = 20
            *<li> maximum vertical speed for successful landing, standard value = 20
            *<li> amount of starting fuel the spaceship has, standard value = 500
            *<li> rate at which spaceship's engine consumes fuel, standard value = 15
            *<li> maximum rotation for successful landing, standard value = 0.1
            *<li> R part of RGB color which applies to the platform, standard value = 0
            *<li> G part of RGB color which applies to the platform, standard value = 255
            *<li> B part of RGB color which applies to the platform, standard value = 0
            *<li> R part of RGB color which applies all terrain lines except for the platform, standard value = 255
            *<li> G part of RGB color which applies all terrain lines except for the platform, standard value = 255
            *<li> B part of RGB color which applies all terrain lines except for the platform, standard value = 255
            *<li> int to determine if terrain should be autogenerated, equals 1 if yes, any other value if not
            *<li> number of points for which their heights will be generated, if autogenerated is not 1 it's a placeholder
            *<li> number of points from which the platform is made, if autogenerated is not 1 it's a placeholder
            *<li> slope angle, determines how high the height difference range is autogenerated points, if autogenerated is not 1 it's a placeholder
            *<li> terrain info, 2 dimensional ArrayList holding each level info in one separate array
 *</ul>
     * If it runs out of arraylists for terrain points height information only then it creates a new one,
     * otherwise current one is overriten. This ensures that map info loaded from the file always
     * takes first x levels, after which next ones are randomly generated
     */
    public void parseServerInfo() {
        maxLives = (int)readString();
        if(lives == -1) {
            lives = maxLives;
        }
        startingPosition.x = readString();
        startingPosition.y = readString();
        gravity = readString();
        accelerationRate = readString();
        rotationRate = readString();
        landingXSpeed = readString();
        landingYSpeed = readString();
        fuel = readString();
        fuelLossRate = readString();
        maxRotation = readString();
        int r, g, b;
        r = (int)readString();
        g = (int)readString();
        b = (int)readString();
        platformColor = color(r,g,b);
        r = (int)readString();
        g = (int)readString();
        b = (int)readString();
        lineColor = color(r,g,b);
        autoGenTerrain = (int)readString();
        numberOfTerrainPoints = (int)readString();
        platformSize = (int)readString();
        slopeAngle = readString();
        //read terrain info
        if (autoGenTerrain != 1) {
            int i = 0, j = 0;
            while(serverInfo.length() > 1) {

                if(terrainPoints.size() <= i) {
                    terrainPoints.add(new ArrayList<Float>());
                }
                else {
                    terrainPoints.get(i).clear();
                }

                while(serverInfo.charAt(0) != ';') {
                    terrainPoints.get(i).add(readString());
                    j++;
                }
                j = 0;
                i++;
                serverInfo = serverInfo.substring(1);
            }
            serverInfo = "";
        }
    }

    /**additional function for parsing, for
     * @see #parseServerInfo()
     * finds the next chunk of information
     * ending with a comma, extracts it from the string, then removes it from
     * the string and returns extracted value
     *
     * @return value extracted from string
     */
    public float readString () {
        int index = serverInfo.indexOf(',');
        float result = Float.parseFloat(serverInfo.substring(0,index));
        serverInfo = serverInfo.substring(index+1);
        return result;
    }

    /**Function to keep track of all highscores, updating
     * one if player beats his own score, or adding new
     * one if he beats another player, highscores are updated
     * at the end of every map
     */
    public void updateHighscores() {
        for(int i=0; i<10; i+=2) {
            if(score > Float.parseFloat(highscores.get(i))) {
                if(highscores.get(i+1) == playerName) {
                    highscores.remove(i+1);
                    highscores.remove(i);
                }
                highscores.add(i, String.valueOf(score));
                highscores.add(i+1, playerName);
                return;
            }
        }
    }








    /**Animation class is just a data structure to keep
     * track of animation parameters in Sprite class methods
     */
    class Animation {
        int x, y, widthW, heightW, frames;
        float frameDuration;
        boolean loop;

        public Animation(int x, int y, int widthW, int heightW, int frames, float frameDuration, boolean loop) {
            this.x = x;
            this.y = y;
            this.widthW = widthW;
            this.heightW = heightW;
            this.frames = frames;
            this.frameDuration = frameDuration;
            this.loop = loop;
        }
    }

    /**possible states of created spaceship, it's always
     * in exactly 1 of these 4 states
     */
    public enum State {IDLE, FLYING, DESTROYED, LANDED};


    /** spaceship class handles most all parameters tied directly to spaceship object
     * and its movement. It handles all collision, keeps track of all animations,
     * calculates spaceship velocity and keeps track of it, updates its position,
     * calculates remaining fuel, handles user input that consists of arrows:
     * UP, LEFT and RIGHT. Checks for successful landing or crash and changes
     * spaceship's state accordingly and holds spaceship's drawing method.
     */
    class Spaceship {
        Sprite sprite;
        PVector position;
        float rotationValue = 0;
        float defaultSize = 15.5f;
        float currentSize = defaultSize;
        float gravity;
        float accelerationRate;
        float rotationRate;
        float distanceSqrt;
        float distanceRatio;
        float landingXSpeed;
        float landingYSpeed;
        float maxRotation;
        float fuel;
        float fuelLossRate;
        PVector velocity = new PVector(0,0);
        PVector thrust;
        boolean thrusting = false;
        boolean crash = false;
        State state = State.IDLE;

        /**
         * spaceship contructor, initialized with values given by the main lunarlander class,
         * also creates animations for all 4 states, drawn from the same file "ship.png"
         *
         * @param position PVector of starting spaceship position (x,y), starting from top left corner
         * @param gravity gravity strength
         * @param accelerationRate trust strength, same scaling as gravity
         * @param rotationRate rotation speed
         * @param landingXSpeed maximum horizontal speed for a successful landing
         * @param landingYSpeed maximum vertical speed for a successful landing
         * @param fuel starting amount of fuel
         * @param fuelLossRate number of fuel points lost per second
         * @param maxRotation maximum allowed rotation for a successful landing
         */
        public Spaceship(PVector position, float gravity, float accelerationRate, float rotationRate,  float landingXSpeed,  float landingYSpeed, float fuel, float fuelLossRate, float maxRotation) {
            this.position = position;
            this.gravity = gravity;
            this.accelerationRate = accelerationRate;
            this.rotationRate = rotationRate;
            this.landingXSpeed = landingXSpeed;
            this.landingYSpeed = landingYSpeed;
            this.fuel = fuel;
            this.fuelLossRate = fuelLossRate;
            this.maxRotation = maxRotation;

            this.sprite = new Sprite(loadImage("ship.png"));
            sprite.animations.put("flying", new Animation(66, 118, 41, 31, 3, 120, true));
            sprite.animations.put("idle", new Animation(16, 118, 36, 31, 1, 120, false));
            sprite.animations.put("destroyed", new Animation(5, 59, 47, 34, 4, 120, false));
            sprite.changeAnimation("idle");
        }

        /** update animation state potentially changing
         * its frame. Also updates spaceship's state
         * calling proper function tied to given state.
         *
         *
         * @param timer time passed in ms since last frame
         */
        public void update(float timer) {
            sprite.updateAnimation(timer);

            switch (state) {
                case IDLE:
                    ready();
                    break;
                case FLYING:
                    flying(timer);
                    break;
                case DESTROYED:
                    destroyed();
                    break;
                case LANDED:
                    landed();
                    break;
            }
        }

        /**starting function, when user pressed arrow UP
         * the spaceship starts and changes state to flying
         * (also we can set starting velocity here if necessary)
         */
        private void ready(){
            if(keysPressed.contains(UP)) {
                //velocity.set(0, -1);
                state = State.FLYING;
            }
        }

        /**main spaceship state, this function handles arrow
         * input by applying rotation, dding speed, applying
         * gravity and reducing current fuel based
         * on time passed since last frame in ms (timer).
         * It also adds bouncing if ship colides with window's
         * top, left or right edge reversing its velocity.
         * uses helper function collisionCheck()
         * @see #collisionCheck()
         * to check for collisions with terrain.
         *
         * @param timer
         */
        private void flying(float timer) {
            //apply rotation
            if (keysPressed.contains(LEFT)) {
                rotationValue -= rotationRate * (timer/1000);
            }
            if (keysPressed.contains(RIGHT)) {
                rotationValue += rotationRate * (timer/1000);
            }

            //apply gravity
            velocity.add(0, gravity*(timer/1000));

            //apply engine thrust
            if(keysPressed.contains(UP) && fuel > 0) {
                if (!thrusting) {
                    sprite.changeAnimation("flying");
                    thrusting = true;
                }
                thrust = PVector.fromAngle(rotationValue - PI/2);
                thrust.mult(accelerationRate * timer/1000);
                velocity.add(thrust);

                //reduce fuel
                fuel -= fuelLossRate * timer/1000;
            }
            else {
                sprite.changeAnimation("idle");
                thrusting = false;
            }

            //update ship position
            position.add(PVector.mult(velocity, timer/1000));

            //bounce from edges
            if(position.x < currentSize || position.x > width - currentSize) {
                velocity.x = -velocity.x;
                rotationValue = -rotationValue;
            }
            if(position.y < currentSize || position.y > height - currentSize) {
                velocity.y = -velocity.y;
                rotationValue = -rotationValue;
            }


            collisionCheck();
        }
        private void destroyed(){
            reset = false;
        }

        private void landed(){
            state = State.LANDED;
            reset = false;
        }

        /**Function to handle collision detection with terrain.
         * It checks if the distance between the middle of spaceship's
         * hitbox and each terrain line (or rather first from 2 points
         * that make the line, then calculates the distance between
         * the middle of spaceship's hitbox and the closest point on that
         * line) on the board is larger than spaceship's hitbox size.
         * Then checks if ship has touched or passed the terrain, and
         * determines if it has crashed or landed.
         * uses helper function crashCheck() to check if all
         * landing parameters were met
         * @see #crashCheck(PVector, PVector) beginning and ending points of the line that made contact with the spaceship
         */
        private void collisionCheck () {
            for(int i=0; i<terrainPoints.get(level).size() - 1; i++) {
                PVector begin = calculatePoint(i);
                PVector end = calculatePoint(i+1);

                //calculate distance from the terrain
                distanceRatio = ((position.x - begin.x) * (end.x - begin.x) + (position.y - begin.y) * (end.y - begin.y)) / PVector.sub(end, begin).magSq();

                if(distanceRatio < 0) {
                    distanceSqrt = PVector.sub(position, begin).magSq();
                }
                else if (distanceRatio > 1) {
                    distanceSqrt = PVector.sub(position, end).magSq();
                }
                else {
                    float x = begin.x + distanceRatio * (end.x - begin.x);
                    float y = begin.y + distanceRatio * (end.y - begin.y);

                    //closest point on given line
                    PVector calculatedPoint = new PVector(x,y);
                    distanceSqrt = PVector.sub(position, calculatedPoint).magSq();
                }

                // crashed
                if (distanceSqrt < currentSize*currentSize) {
                    if(crashCheck(begin, end)) {
                        state = State.DESTROYED;
                        sprite.changeAnimation("destroyed");
                        break;
                    }
                    //landed
                    else {
                        state = State.LANDED;
                        sprite.changeAnimation("idle");
                        velocity.set(0,0);
                        rotationValue = 0;
                        position.y = begin.y - currentSize;
                    }

                }

            }

        }

        /**Checks if horizontal velocity, vertical velocity and rotation is within allowed range
         *
         * @param begin starting point coordinates of the line making contact with the spaceship
         * @param end ending point coordinates of the line making contact with the spaceship
         * @return true if crashed, false if landed
         */
        public boolean crashCheck(PVector begin, PVector end) {
            //check if landed not on platform
            if (begin.y != end.y) {
                return true;
            }
            //check if speed too high
            else if(abs(velocity.x) > landingXSpeed || abs(velocity.y) > landingYSpeed) {
                return true;
            }
            //check if rotation less than 18 degrees
            else if (abs(rotationValue) > maxRotation) {
                return true;
            }
            return false;
        }

        /**
         * draw spaceship model animation with applied
         * coordinates and rotation
         */
        public void draw() {

            pushMatrix();
            translate(position.x, position.y);
            rotate(rotationValue);
            sprite.draw();
            popMatrix();

            //debug display hitbox
    /* noFill();
    stroke(255,0,0);
    ellipse(position.x, position.y, size*2, size*2); */
        }
    }


    /**
     * class that handles drawing and updating animations,
     * updating their frame, location and rotation. Also uses
     * Animation class to
     * create all animations by cutting out each frame from
     * given png file
     */
    public class Sprite {
        PImage sprite;

        HashMap<String, Animation> animations = new HashMap<String, Animation>();
        Animation activeAnimation;
        float animationTimer; //milliseconds
        int activeFrame;

        /**
         * default contructor
         * @param spriteInput
         */
        public Sprite(PImage spriteInput) {
            this.sprite = spriteInput;
        }

        /**
         * change active animation reseting its timer
         * @param animationName new animation to play
         */
        public void changeAnimation(String animationName) {
            activeAnimation = animations.get(animationName);
            animationTimer = 0;
        }

        /**
         * update animation's frame based on time passed
         * since last frame in ms
         * @param timePassed time passed since last frame in ms
         */
        public void updateAnimation(float timePassed) {
            animationTimer += timePassed;
        }

        /**select which frame should be displayed and draw it,
         * if animation is set to loop then possibly repeat frames,
         * if not then stop at the last frame.
         * Uses helper function drawFrame() to draw
         * @see #drawFrame()
         *
         */
        public void draw() {
            activeFrame = (int)(animationTimer/activeAnimation.frameDuration);
            if(activeAnimation.loop) {
                activeFrame = activeFrame % activeAnimation.frames;
            }
            else if (activeFrame > activeAnimation.frames) {
                activeFrame = activeAnimation.frames - 1;
            }
            drawFrame();
        }

        /**helper function used to draw selected animation frame
         * with selected earlier parameters, in the middle of
         * spaceship's hitbox
         */
        public void drawFrame () {
            imageMode(CENTER);
            int startingX = activeAnimation.x + activeAnimation.widthW*activeFrame;
            //position               //target size                    //source top-left                                       //source bottom-right
            image(sprite, 0, 0, activeAnimation.widthW, activeAnimation.heightW, startingX, activeAnimation.y, startingX + activeAnimation.widthW, activeAnimation.y + activeAnimation.heightW);
        }
    }









    public void settings() {  size(1640, 910, JAVA2D); }
    static public void main(String[] passedArgs) {
        String[] appletArgs = new String[] { "lunarlander" };
        if (passedArgs != null) {
            PApplet.main(concat(appletArgs, passedArgs));
        } else {
            PApplet.main(appletArgs);
        }
    }
}
